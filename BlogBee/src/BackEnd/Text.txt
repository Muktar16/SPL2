a few days ago i was listening to a conversation between sal khan and grant sanderson to the biggest online educators in the world and they were talking about how the education system should evolve to fix some of the problems it has and sal khan you probably know from khan academy grant sanderson runs a really huge math youtube channel called three blue one brown in education there's a concept of traditional learning versus mastery learning and so traditional learning is about checking whether you've studied something for a long enough time period whereas mastery based learning is about do you truly understand the content of what is being taught and so sal makes the argument that our education system should shift aggressively toward mastery learning which i think is actually really good advice for most of the education system but for a professional software engineer i think mastery learning is actually detrimental and so in this video i want to talk about why i think it's a mistake to try and master your code base and what you should do instead the mastery is hey if you if you're at 80 keep working on it so that you can get to a better level or maybe you move on to the next concept but at some point come back and review this 80 so you can get it to a 90 or 95 or 100 percent uh that's matchy learning traditional learning is you got an 80 too bad you're a c student let's move on to the next concept somehow expecting you to master it and we know where that's leading that's leading to the seventy percent of kids having to take six sixth or seventh grade math even though they've they've spent six years trying to learn things beyond that the idea of mastery learning for education and even including software engineering makes a lot of sense when you learn about the difference between the two ideologies but that's why i think it's actually counterintuitive to apply that blindly to a professional software engineer so traditional education means it's much more about clocking and clocking out so you know you're in fourth grade you're learning your multiplication tables your times tables and even if you don't really understand or you haven't really properly understood what it means to multiply numbers you move on to fifth grade you've got like a b or a c grade you move on to fifth grade and that's a huge problem because then your foundation is weak you're not going to do well in your fifth grade math class or your 10th grade math class and the result which is what style talks about is that today 70 of students who are going into community college they have to go back and take remedial math and what that means is the community college is basically saying that hey we actually don't think you know algebra or pre-algebra well enough to even think about taking precalculus or calculus and that's a huge issue right we're basically turning students through this education education system without properly equipping them with the knowledge they need on the other hand mastery based learning is much more about do you really understand what you're being taught can you relate one concept to what you learned last month or last year which is really the true test of mastery is can you relate concepts to one another can you see how they build up on top of one another so then why do i think that mastery learning is bad for software engineers it's because the main job of an engineer is to manage information or manage complexity and the way you manage complexity is something called abstraction and so the idea is that when you have this code base when you have a team of people you have to be able to trust the api which is basically hiding a lot of the complexity behind it and just using an api to get things done and you have to be okay with not mastering a large part of the code it's not even knowing a large part of the code base right and that's the only way to be productive as a software engineer is understanding that you're building up on top of abstractions and getting things done despite not knowing you know what's underneath you in my opinion this is one of the core issues i see when a new software engineer joins a company or joins a team that they get lost in all the complexity and the core job i tell them is right now you should focus on just going into your part of the code base define your niche to find your area and become an expert in that and ignore everything around you that's the point of abstraction and at any reasonably sized tech company software systems are built through many different layers of abstraction another analogy i like to use here is you could imagine the code base as a really big elephant and you're looking at one part of the elephant and so even though you don't know the perspective of another engineer who might be looking at the back side of the elephant and you're looking at the trunk of elephant you can still work and improve and clean your part of the elephant you're part of the code base without needing to know about the whole perspective the whole picture elephant which no one can really have because elephant is so huge i'll give you two concrete examples where i feel like mastery learning actually hurt me quite a bit in my journey to become a engineer the first when i was a student at stanford the way that a lot of classes would work is an assignment would basically be a coding project but in that coding project there would be a lot of starter code which would either be you know things that were already written out for you or maybe a test harness um like for example in my compilers class we were writing compiler and a lot of the code was done for us but there were like a couple modules a couple files where we had to fill out the code and the issue is that you know when i got the assignment my first inclination was let me master the assignment let me truly understand all the different parts of the starter code and it would literally take me days or weeks to even understand the thousands of lines of code that were already written for me and that was a huge detriment because i actually didn't get to the interesting part the part where i wrote the code until pretty much a deadline and i did pretty poorly in that compiler's class and so the idea is that you know programming is something where you learn by doing and if you spend all your time trying to master and trying to read through all this other code you're never really going to get better the best way to get better is by actually just trying and failing another example is when i joined facebook as an android engineer and facebook android is probably one of the most probably the most complicated android app in the world there are literally millions of lines of code and different services interacting and just it's literally impossible for a single person or even a single team to understand the android code base at facebook and so as a new engineer i think i just was overwhelmed i didn't know where to start i didn't know where to end i couldn't really make heads or tails of my starter task and it was only until i had some guidance and someone who really showed me step by step how to get started is where i started to feel more productive and i got things done and so if you are overwhelmed by this idea of mastery i think that's more of a detriment rather than something that's actually going to help you in your engineering career one thing i want to call out though is that there is a distinction between being lazy and trusting the abstraction i talked about this a little bit in my video about what i wish i knew when i joined facebook i'll leave a link for that but don't let a lack of mastery slow you down from making impact and being productive right the best engineers i know they're able to dive into a code base and even if they don't really know what's happening you don't really understand why some things are in the way it is you get enough knowledge out of it that you can make your change we can make it locally and then send it out for feedback or you know keep improving on that but don't get stuck by having to master everything and then using that as a reason not to do anything at all and the other element here is that i do have a bias as a founder which is probably contributing to my disdain for mastery learning right so i have this app called taro and i'm the co-founder of this company and we're designed to help upscale software engineers we want to have the best resources and frameworks from the best people delivered to you in our mobile app tarot so jointaro.com i'll leave a link for the description but your job as an entrepreneur as a founder is that you have to be 100 okay with not knowing everything and in fact your job is to just know barely enough to get the ball rolling and then you hire in someone who knows that job better than you design engineering marketing figuring out how to charge people and figure out all the revenue all of that are things that if you waited until you were a master at any one of those domains people would just never start companies right and so i think certainly as a founder mastery learning is a really bad idea and i would argue for a software engineer too where your job is just to get things done to land impact waiting until you have mastery is a really bad idea that's all i had for this video i'd love to understand from you how do you think about the distinction between mastery learning versus traditional learning and how do you think that applies to software engineering let me know in the comments thanks for watching and i'll see you in the next one